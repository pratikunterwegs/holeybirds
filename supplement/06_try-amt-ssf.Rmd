---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Try SSF

## Load libraries and prepare files

```{r}
# libs for data
library(data.table)
library(lubridate)
library(tidyverse)
library(sf)

# library for atlas data
library(amt)

# plotting
library(ggplot2)
library(ggspatial)
library(colorspace)
```

## Load data

```{r}
files = list.files("data/processed/data_preprocessed", pattern = "smooth",
                   full.names = T)
```


```{r}
# read files
data = fread(files[1])
setDF(data)

# make tibble
data = as_tibble(data)

# handle timesteps
data = mutate(data, time = as.POSIXct(
  UNIX, origin = "1970-01-01", tz = "Asia/Jerusalem"
))

# make amt
data = amt::make_track(
  tbl = data, .x = x, .y = y, .t = time,
  
  # set CRS
  crs = sp::CRS(
    st_crs(2039)$proj4string
  )
)

# resample to 30 s with a 5 second tolerance
data_resamp = amt::track_resample(
  data,
  rate = seconds(60),
  tolerance = seconds(5)
) %>% 
  
  # filter bursts with at least 5 points
  # this is the filtering out of proto-patches essentially
  amt::filter_min_n_burst(
    min_n = 5
  ) %>% 
  amt::steps_by_burst() %>% 
  amt::time_of_day(
    include.crepuscule = F
  )
```

### Get covariate layer

```{r}
# get ndvi
ndvi = raster("data/rasters/raster_hula_ndvi_transformed.tif")

# get landcover
lc = raster("data/rasters/raster_hula_lc_reclass.tif")

# assign name
names(ndvi) = "ndvi"
names(lc) = "landcover"
```

### Fit model

```{r}
data_resamp = data_resamp %>% 
  amt::random_steps(n = 29) %>% 
  amt::extract_covariates(ndvi) %>% 
  amt::extract_covariates(lc) %>% 
  mutate(landcover = factor(landcover))


  # mutate(
  #   log_sl_ = log(sl_)
  # ) %>% 
m1 = data_resamp %>% 
  amt::fit_issf(
    # case_ ~ ndvi + sl_ + ndvi:tod_end_ + sl_:tod_end_ + strata(step_id_)
    case_ ~ sl_ + ndvi + landcover + strata(step_id_) + sl_:landcover
  )

# get distribution of step lengths
step_dist = sl_distr(m1)

# adjust distribution shape based on model
shape_day = step_dist$params$shape + coef(m1)["sl_"]
shape_night = step_dist$params$shape + coef(m1)["sl_"] + coef(m1)["sl_:tod_end_night"]

step_dist$params$scale * c(shape_day, shape_night)
```

### Utilisation distribution

```{r}
# set values NA to 0
raster::values(lc)[is.na(raster::values(lc))] = 0
```

Does not work on LC data as it is too coarse.

```{r}
mk = amt::movement_kernel(
  scale = step_dist$params$scale,
  shape = step_dist$params$shape + m1$model$coefficients["sl_"],
  template = ndvi
)

hk = amt::habitat_kernel(
  coef = list(ndvi = coef(m1)["ndvi"]), resources = ndvi, exp = TRUE
)

ssud = amt::simulate_ud(
  movement_kernel = mk,
  habitat_kernel = hk,
  start = as.numeric(
    data_resamp[1, c("x1_", "y1_")]
  ),
  n = 1e7
)
```

