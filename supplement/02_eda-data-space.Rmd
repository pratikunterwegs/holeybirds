---
editor_options: 
  chunk_output_type: console
---

# Exploratory data analysis: Track Quality

## Load libraries

```{r}
# libs for data
library(data.table)
library(glue)
library(stringi)

# libs for plotting
library(ggplot2)
library(atlastools)
```

## Read data and plot by species

### Prepare species names and paths

### Explore

```{r}
data_raw <- holeybirds::read_tracking_data(
  sp_name = "Passer",
  treatment = "Moulting", index = 2
)

data_raw[, c("day", "hour") := list(
  lubridate::date(as.POSIXct(UNIX, origin = "1970-01-01", tz = "Asia/Jerusalem")),
  lubridate::hour(as.POSIXct(UNIX, origin = "1970-01-01", tz = "Asia/Jerusalem"))
)]

# split by day
data_raw = split(data_raw, by = "day")

# remove data with few rows
data_raw = data_raw[vapply(data_raw, function(df) { 
  nrow(df) > 500 
}, FUN.VALUE = T)]

data_raw = lapply(data_raw, function(df) {
  # check if filtering works
  df[, c("speed_in", "speed_out", "angle") := list(
    atl_get_speed(data = df, x = "x", time = "UNIX", type = "in"),
    atl_get_speed(data = df, time = "UNIX", type = "out"),
    atl_turning_angle(data = df, time = "UNIX")
  )]
  # fix missingle angles due to same position, assign 0
  df[, angle := nafill(angle, type = "const", fill = 0)]
})

# make a copy
data_proc <- copy(data_raw)

# filter on speed
data_proc = lapply(data_proc, function(df) {
  atl_filter_covariates(
    df,
    filters = c(
      "(speed_in < 3 & speed_out < 3) | angle < 20"
    )
  )
})

data_proc = data_proc[vapply(data_proc, function(df) { 
  nrow(df) > 200 
}, FUN.VALUE = T)]

# # filter repeatedly on speed
# data_proc = lapply(data_proc, function(df) {
#   while (max(df$speed_in, na.rm = T) > 1.5) {
#     # print(sprintf("max speed = %f", max(df$speed_in, na.rm = T)))
#     
#     # filter again on speed
#     df <- atl_filter_covariates(
#       df,
#       filters = c(
#         "(speed_in < 1.5 & speed_out < 1.5) | angle < 5"
#       )
#     )
#     # recalculate & check if filtering works
#     df[, c("speed_in", "speed_out", "angle") := list(
#       atl_get_speed(data = df, x = "x", time = "UNIX", type = "in"),
#       atl_get_speed(data = df, time = "UNIX", type = "out"),
#       atl_turning_angle(data = df, time = "UNIX")
#     )]
#   }
#   df
# })

interval = 120 # in seconds
data_proc = lapply(data_proc, function(df) {
  df[, burst := cumsum(c(0, diff(UNIX)) > 60) + 1]
  df[, burst_size := length(UNIX), by = "burst"]
  
  df = df[burst_size > 3,]
  
})
# split by burst and smooth
# data_proc = lapply(data_proc, split, by = "burst")

a = copy(data_proc[[2]])

# now smooth
a = lapply(a, atl_median_smooth, x = "x", y = "y",
  time = "UNIX", moving_window = 5)

# split by burst
a = rbindlist(a)

# plot to check
p = ggplot(a)+
  geom_path(data = data_raw[[2]], aes(x, y), col = "grey")+
  geom_path(aes(x, y),
            show.legend = F)+
  geom_point(aes(x, y), shape = 1)+
  # facet_wrap(~burst, scales = "free")+
  theme_void()

ggplotly(p)
```

### Recurse

```{r}
library(recurse)
# get residence times
data_residence <- lapply(data_proc, function(dt) {

  # do basic recurse -- refer to Bracis et al. (2018) Ecography
  dt_recurse <- getRecursions(
    x = dt[, c("x", "y", "UNIX", "TAG_ID")],
    radius = 10,
    timeunits = "mins"
  )

  # get revisit stats column provided as recurse output
  dt_recurse <- setDT(
    dt_recurse[["revisitStats"]]
  )

  # count long absences from the each position -- long absence is 5 mins
  dt_recurse[, timeSinceLastVisit :=
    ifelse(is.na(timeSinceLastVisit), -Inf, timeSinceLastVisit)]
  dt_recurse[, longAbsenceCounter := cumsum(timeSinceLastVisit > 5),
    by = .(coordIdx)
  ]

  # filter data to exclude revisits after the first long absence of 60 mins
  dt_recurse <- dt_recurse[longAbsenceCounter < 1, ]

  # calculate the residence time as the sum of times inside
  # before the first 'long absence'
  # also calculate the First Passage Time and the number of revisits
  dt_recurse <- dt_recurse[, list(
    resTime = sum(timeInside),
    fpt = first(timeInside),
    revisits = max(visitIdx)
  ),
  by = .(coordIdx, x, y)
  ]

  # prepare to merge existing data with recursion data
  dt[, coordIdx := seq(nrow(dt))]

  # merge the revised recursion analysis data with the tracking data
  dt <- merge(dt,
    dt_recurse[, c("coordIdx", "resTime")],
    by = c("coordIdx")
  )

  # ensure the data are ordered in ascending order of time
  setorderv(dt, "time")

  # print message when done
  message(sprintf("TAG %s residence times done", unique(dt$TAG_ID)))

  # return the dataframe
  dt
})
```


```{r res_patch}
a = copy(data_proc[[1]])
a[, id := "TAG_ID"]
a$time = NULL
a$time = a$UNIX

# remove transit
a = atl_filter_covariates(
      a,
      filters = c(
        "(speed_in < 1.5 & speed_out < 1.5) | angle < 5"
      )
    )

b = atl_res_patch(a, buffer_radius = 3, lim_spat_indep = 50, lim_time_indep = 10)
d = atl_patch_summary(b, which_data = "points")

ggplot(data_proc[[1]])+
  geom_path(aes(x, y))+
  geom_point(
    data = d,
    aes(x, y, col = factor(patch))
  )+
  geom_point(
    data = b,
    aes(x_median, y_median, fill = duration / 60),
    size = 10,
    alpha = 0.8,
    shape = 21
  )+
  scale_fill_distiller(direction = 1)


# select columns
data_thin <- data_proc[, c(
  "TAG_ID", "sp", "treat",
  "UNIX", "x", "y"
)]

# rename
setnames(data_thin, old = "UNIX", new = "time")

# thin to 20s
data_thin <- atl_thin_data(
  data = data_thin, interval = 30,
  id_columns = c("TAG_ID", "sp", "treat"),
  method = "aggregate"
)

# add day and hour
data_thin[, c("day", "hour") := list(
  lubridate::date(as.POSIXct(time, origin = "1970-01-01", tz = "Asia/Jerusalem")),
  lubridate::hour(as.POSIXct(time, origin = "1970-01-01", tz = "Asia/Jerusalem"))
)]
```


```{r}
# plot and check
ggplot() +
  geom_path(
    data = data_raw,
    aes(x, y),
    col = "grey",
    alpha = 0.3,
    size = 0.3
  ) +
  geom_path(
    data = data_thin,
    aes(x, y),
    alpha = 0.2
  ) +
  geom_point(
    data = data_thin,
    aes(x, y, colour = hour),
    shape = 19,
    alpha = 0.7
    # show.legend = F
  ) +
  facet_wrap(~day) +
  scico::scale_colour_scico(
    palette = "romaO",
    name = "Hour",
    limits = c(0, 23),
    breaks = c(6, 12, 18),
    labels = c("6 AM", "Noon", "6 PM"),
    # trans = "sqrt",
    # option = "G",
    direction = 1
    # begin = 0.1, end = 0.9,
  ) +
  ggthemes::theme_map() +
  ggspatial::annotation_scale(location = "tl", style = "ticks") +
  coord_sf(
    crs = 2039,
    xlim = range(data_proc$x),
    ylim = range(data_proc$y)
  )
```

### Save example plot

```{r}
# save
ggsave(
  filename = "figures/fig_Acrocephalus_daily.png"
)
```
