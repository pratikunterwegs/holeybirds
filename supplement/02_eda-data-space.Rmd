---
editor_options: 
  chunk_output_type: console
---

# Exploratory data analysis: Track Quality

## Load libraries

```{r}
# libs for data
library(data.table)
library(glue)
library(stringi)

# libs for plotting
library(ggplot2)
library(atlastools)
```

## Read data and plot by species

### Prepare species names and paths

### Explore

```{r}
data_raw <- holeybirds::read_tracking_data(
  sp_name = "Acrocephalus",
  treatment = "NonMoulting", index = 8
)[d == "D"]

data_raw[, c("day", "hour") := list(
  lubridate::date(as.POSIXct(UNIX, origin = "1970-01-01", tz = "Asia/Jerusalem")),
  lubridate::hour(as.POSIXct(UNIX, origin = "1970-01-01", tz = "Asia/Jerusalem"))
)]

# split by day
data_raw <- split(data_raw, by = "day")

# remove data with few rows
data_raw <- data_raw[vapply(data_raw, function(df) {
  nrow(df) > 500
}, FUN.VALUE = T)]

data_raw <- lapply(data_raw, function(df) {
  # check if filtering works
  df[, c("speed_in", "speed_out", "angle") := list(
    atl_get_speed(data = df, x = "x", time = "UNIX", type = "in"),
    atl_get_speed(data = df, time = "UNIX", type = "out"),
    atl_turning_angle(data = df, time = "UNIX")
  )]
  # fix missingle angles due to same position, assign 0
  df[, angle := nafill(angle, type = "const", fill = 0)]
})

# make a copy
data_proc <- copy(data_raw)

# filter on speed
data_proc <- lapply(data_proc, function(df) {
  atl_filter_covariates(
    df,
    filters = c(
      "(speed_in < 3 & speed_out < 3) | angle < 20"
    )
  )
})

data_proc <- data_proc[vapply(data_proc, function(df) {
  nrow(df) > 500
}, FUN.VALUE = T)]

# warn for all data lost
if (purrr::is_empty(data_proc)) {
  warning("data proc is empty, all data cleaned away")
}

d <- copy(data_proc[[1]])

ggplot(d, aes(x, y)) +
  geom_point() +
  geom_path()

# now smooth
data_proc <- lapply(data_proc, atl_median_smooth,
  x = "x", y = "y",
  time = "UNIX", moving_window = 5
)

# try aggregate
data_agg <- lapply(data_proc, function(df) {
  df <- df[, c("UNIX", "x", "y", "sp", "treat", "TAG_ID")]
  setnames(df, "UNIX", "time")
  df <- atl_thin_data(
    data = df, interval = 120,
    id_columns = c("TAG_ID", "sp", "treat"),
    method = "aggregate"
  )
})

# plot aggregated data
plots <- Map(function(df_raw, df_preproc) {
  ggplot(df_preproc, aes(x, y)) +
    geom_path(
      data = df_raw,
      alpha = 0.2,
      col = "red"
    ) +
    geom_point(
      col = "steelblue",
      shape = 1
    ) +
    geom_path(
      col = "steelblue"
    )
}, data_raw, data_proc)

plots |> patchwork::wrap_plots()
```

### Recurse

```{r}
library(recurse)
# get residence times
data_residence <- lapply(data_proc, function(dt) {

  # do basic recurse -- refer to Bracis et al. (2018) Ecography
  dt$res_time <- getRecursions(
    x = dt[, c("x", "y", "UNIX", "TAG_ID")],
    radius = 10,
    timeunits = "mins"
  )$residenceTime

  # print message when done
  message(sprintf("TAG %s residence times done", unique(dt$TAG_ID)))

  dt
})
```

### Plot residence time

```{r}
# plot aggregated data
plots <- Map(function(df_raw, df_preproc) {
  ggplot(df_preproc, aes(x, y)) +
    geom_point(
      data = df_raw,
      aes(x, y),
      alpha = 0.1
    ) +
    geom_path(
      col = "grey"
    ) +
    geom_point(
      aes(col = res_time),
      shape = 16
    ) +
    scale_colour_viridis_c(
      option = "H",
      trans = "sqrt",
      breaks = c(2, 10, 20, 60),
      limits = c(2, NA),
      na.value = "grey"
    ) +
    theme_void()
}, data_raw, data_residence)

plots |> patchwork::wrap_plots()
```


```{r res_patch}
# make residence patches
data_patch <- copy(data_residence)
data_patch <- lapply(data_patch, function(df) {
  df[, id := "TAG_ID"]
  df$time <- NULL
  df$time <- df$UNIX

  df <- atl_filter_covariates(
    df,
    filters = c(
      "res_time >= 2"
    )
  )

  b <- atl_res_patch(a, buffer_radius = 3, lim_spat_indep = 10, lim_time_indep = 5)

  b
})

# make plots
plots <- Map(function(df_raw, data_rp) {
  ggplot(df_raw) +
    geom_point(
      aes(x, y),
      alpha = 0.1
    ) +
    geom_path(
      data = data_rp,
      aes(x_median, y_median),
      col = "red",
      size = 1
    ) +
    geom_point(
      data = b,
      aes(x_median, y_median,
        fill = duration / 60
      ),
      shape = 21
    ) +
    scale_fill_viridis_c(
      option = "H"
    ) +
    theme_void()
}, data_raw, data_patch)

plots |> patchwork::wrap_plots()
```
