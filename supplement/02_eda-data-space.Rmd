---
editor_options: 
  chunk_output_type: console
---

# Exploratory data analysis: Track Quality

## Load libraries

```{r}
# libs for data
library(data.table)
library(glue)
library(stringi)

# libs for plotting
library(ggplot2)
library(atlastools)
library(dbscan)
library(patchwork)

# source mean filter
Rcpp::sourceCpp("src/weighted_mean_filter.cpp")
```

## Read data and plot by species

### Prepare species names and paths

### Explore

```{r}
data_raw <- holeybirds::read_tracking_data(
  sp_name = "Acrocephalus",
  treatment = "NonMoulting", index = 8
)[d == "D"]

data_raw[, c("day", "hour") := list(
  lubridate::date(as.POSIXct(UNIX, origin = "1970-01-01", tz = "Asia/Jerusalem")),
  lubridate::hour(as.POSIXct(UNIX, origin = "1970-01-01", tz = "Asia/Jerusalem"))
)]

# split by day
data_raw <- split(data_raw, by = "day")

# remove data with few rows
data_raw <- data_raw[vapply(data_raw, function(df) {
  nrow(df) > 500
}, FUN.VALUE = T)]

# plot to check
plots = lapply(data_raw, function(df) {
  ggplot(df, aes(x, y))+
    geom_point(
      alpha = 0.1
    )
})

plots |> wrap_plots()
```


### Identify outliers on speed and DBSCAN

```{r}
# try dbscan
data_proc = copy(data_raw)

data_proc = lapply(data_proc, function(df) {
  scan = dbscan(df[, c("x", "y")], eps = 2)
  df[, outlier := scan$cluster == 0]
  df
})

plots = Map(function(df_raw, df_proc) {
  ggplot(mapping = aes(x, y))+
    geom_point(
      data = df_raw,
      alpha = 0.1
    )+
    geom_point(
      data = df_proc[!(outlier),],
      col = "steelblue",
      alpha = 0.5
    )
}, data_raw, data_proc)

plots |> wrap_plots()

data_raw <- lapply(data_raw, function(df) {
  # check if filtering works
  df[, c("speed_in", "speed_out", "angle") := list(
    atl_get_speed(data = df, x = "x", time = "UNIX", type = "in"),
    atl_get_speed(data = df, time = "UNIX", type = "out"),
    atl_turning_angle(data = df, time = "UNIX")
  )]
  
  # fix missingle angles due to same position, assign 0
  df[, angle := nafill(angle, type = "const", fill = 0)]
  
  # classify dbscan outlier
  scan = dbscan(df[, c("x", "y")], eps = 3)
  df[, outlier:= scan$cluster == 0]
})
```

### Outlier removal: Combinations of speed and density

```{r}
# make a copy
data_proc <- copy(data_raw)

# filter on speed
data_proc <- lapply(data_proc, function(df) {
  atl_filter_covariates(
    df,
    filters = c(
      "((!outlier) & (speed_in < 5 & speed_out < 5)) | ((angle < 10) & (angle != 0))"
    )
  )
})

# remove poor data
data_proc <- data_proc[vapply(data_proc, function(df) {
  nrow(df) > 500
}, FUN.VALUE = T)]

# warn for all data lost
if (purrr::is_empty(data_proc)) {
  warning("data proc is empty, all data cleaned away")
}

# plot to check
plots = Map(function(df_raw, df_proc) {
  ggplot(mapping = aes(x, y))+
    geom_point(
      data = df_raw,
      alpha = 0.1
    )+
    geom_point(
      data = df_proc[!(outlier),],
      aes(col = outlier),
      alpha = 1
    )+
    scale_colour_viridis_d(
      option = "H",
      begin = 0.1, end = 0.9
    )+
    coord_sf(
      crs = 2039
    )
}, data_raw, data_proc)

plots[[1]]

plots |> wrap_plots()
```

### Median smoothing

```{r}
# copy again
data_smooth = copy(data_proc)

# now smooth
data_smooth <- lapply(data_smooth, atl_median_smooth,
  x = "x", y = "y",
  time = "UNIX", moving_window = 9
)

# # try aggregate
# data_agg <- lapply(data_proc, function(df) {
#   df <- df[, c("UNIX", "x", "y", "sp", "treat", "TAG_ID")]
#   setnames(df, "UNIX", "time")
#   df <- atl_thin_data(
#     data = df, interval = 120,
#     id_columns = c("TAG_ID", "sp", "treat"),
#     method = "aggregate"
#   )
# })

pal = RColorBrewer::brewer.pal(4, "Set1")

# plot aggregated data
plots <- Map(function(df_raw, df_preproc, df_smooth) {
  ggplot(mapping = aes(x, y)) +
    geom_point(
      data = df_raw,
      alpha = 0.5,
      col = "grey"
    ) +
    geom_point(
      data = df_preproc,
      aes(col = !outlier),
      alpha = 0.5
    ) +
    # geom_point(
    #   data = df_smooth,
    #   col = pal[4],
    #   alpha = 0.8
    # )+
    geom_path(
      data = df_smooth,
      col = pal[4],
      alpha = 0.8
    )+
    theme_test()
}, data_raw, data_proc, data_smooth)

plots[[2]] + coord_sf(crs = 2039)

plots |> patchwork::wrap_plots()
```

### Recurse

```{r}
library(recurse)
# get residence times
data_residence <- lapply(data_proc, function(dt) {

  # do basic recurse -- refer to Bracis et al. (2018) Ecography
  dt$res_time <- getRecursions(
    x = dt[, c("x", "y", "UNIX", "TAG_ID")],
    radius = 10,
    timeunits = "mins"
  )$residenceTime

  # print message when done
  message(sprintf("TAG %s residence times done", unique(dt$TAG_ID)))

  dt
})
```

### Plot residence time

```{r}
# plot aggregated data
plots <- Map(function(df_raw, df_preproc) {
  ggplot(df_preproc, aes(x, y)) +
    geom_point(
      data = df_raw,
      aes(x, y),
      alpha = 0.1
    ) +
    geom_path(
      col = "grey"
    ) +
    geom_point(
      aes(col = res_time),
      shape = 16
    ) +
    scale_colour_viridis_c(
      option = "H",
      trans = "sqrt",
      breaks = c(2, 10, 20, 60),
      limits = c(2, NA),
      na.value = "grey"
    ) +
    theme_void()
}, data_raw, data_residence)

plots |> patchwork::wrap_plots()
```


```{r res_patch}
# make residence patches
data_patch <- copy(data_residence)
data_patch <- lapply(data_patch, function(df) {
  df[, id := "TAG_ID"]
  df$time <- NULL
  df$time <- df$UNIX

  df <- atl_filter_covariates(
    df,
    filters = c(
      "res_time >= 2"
    )
  )

  b <- atl_res_patch(a, buffer_radius = 3, lim_spat_indep = 10, lim_time_indep = 5)

  b
})

# make plots
plots <- Map(function(df_raw, data_rp) {
  ggplot(df_raw) +
    geom_point(
      aes(x, y),
      alpha = 0.1
    ) +
    geom_path(
      data = data_rp,
      aes(x_median, y_median),
      col = "red",
      size = 1
    ) +
    geom_point(
      data = b,
      aes(x_median, y_median,
        fill = duration / 60
      ),
      shape = 21
    ) +
    scale_fill_viridis_c(
      option = "H"
    ) +
    theme_void()
}, data_raw, data_patch)

plots |> patchwork::wrap_plots()
```
