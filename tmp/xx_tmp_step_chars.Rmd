
### Get step characteristics

```{r}
tracks <- mutate(
  tracks,
  data = imap(data, function(.x, .y) {

    # print message
    message(sprintf("working on row %i", .y))

    # get end points
    steps <- select(.x, x1_, y1_, x2_, y2_, step_id_, sl_)

    # make sf lines
    steps$geometry <- pmap(steps, function(x1_, y1_, x2_, y2_, step_id_, sl_) {
      # make linear path
      step_path <- st_linestring(
        matrix(c(x1_, y1_, x2_, y2_), nrow = 2, byrow = T)
      )
      step_path
    })

    # MAKE SFC
    steps$geometry <- st_sfc(steps$geometry, crs = 2039)

    # assign ID_sp
    steps$ID_sp <- seq(nrow(steps))

    # filter paths > 10 m, the long steps
    steps_long <- filter(steps, sl_ >= 10) %>%
      select(-sl_)

    # check steps long length
    if (nrow(steps_long) > 0) {

      # sample it every 10m
      steps_long <- steps_long %>%
        mutate(path_samples = st_line_sample(
          geometry,
          density = 1 / 10
        )) %>%
        filter(!st_is_empty(path_samples)) %>%
        select(-geometry)

      # make 5 m buffer
      steps_long <- steps_long %>%
        mutate(
          path_samples = st_buffer(path_samples, dist = 5),
          path_samples = st_sfc(path_samples)
        )

      # cast to multipolygon
      steps_long <- steps_long %>%
        mutate(path_samples = st_cast(path_samples, "MULTIPOLYGON"))

      # make sf and add temp id
      steps_long <- st_as_sf(steps_long, sf_column_name = "path_samples") %>%
        mutate(id_temp_ = seq(nrow(.)))

      # THIS CAN NOW BE PASSED TO VELOX -- some should give NAs due to EMPTY
      ndvi_path <- ndvi_velox$extract(
        sp = steps_long$path_samples,
        fun = function(x) mean(x, na.rm = T),
        df = TRUE
      ) %>%
        as_tibble() %>%
        rename(
          ndvi_step = out,
          id_temp_ = ID_sp
        )

      # get counts for
      lc_vals_path <- lc_velox$extract(sp = steps_long$path_samples, df = TRUE)
      lc_prop_path <-
        lc_vals_path %>%
        rename(lc = "do.call..rbind...out.") %>%
        count(ID_sp, lc) %>%
        group_by(ID_sp) %>%
        mutate(
          lc = sprintf("lc_%i", lc),
          prop = n / sum(n)
        ) %>%
        select(-n) %>%
        pivot_wider(
          names_from = lc,
          values_from = prop,
          values_fill = list(prop = 0)
        ) %>%
        ungroup()

      # add missing samples
      lc_prop_path <- full_join(
        lc_prop_path,
        tibble(ID_sp = seq(nrow(steps_long))),
        by = "ID_sp"
      )

      # get step openness
      data_openness <- lc_prop_path %>%
        # select open classes - open agri, urban, water
        select(matches("(2)|(0)|(5)")) %>%
        # sum the proportion
        rowSums(na.rm = TRUE) %>%
        tibble(
          id_temp_ = seq(length(.)),
          step_openness = .
        )

      # add assert
      assertthat::assert_that(
        nrow(data_openness) == nrow(steps_long),
        msg = "step openness values fewer than long steps"
      )

      # add to steps long
      steps_long <- steps_long %>%
        st_drop_geometry() %>%
        # add ndvi path
        left_join(ndvi_path, by = "id_temp_") %>%
        left_join(data_openness, by = "id_temp_")

      # remove excess data
      steps_long <- steps_long %>%
        select(-id_temp_)

      # bind with all steps
      steps <- steps %>%
        select(-geometry) %>%
        # join to long steps
        left_join(
          steps_long,
          by = c("x1_", "y1_", "x2_", "y2_", "step_id_", "ID_sp")
        )
    } else {
      steps <- mutate(
        steps,
        ndvi_step = NA_real_,
        step_openness = NA_real_
      )
    }

    # join to get full predictor data
    .x <- left_join(
      .x,
      steps,
      by = c("x1_", "x2_", "y1_", "y2_", "sl_", "step_id_")
    )

    # handle the short steps
    # first NDVI
    .x <- .x %>%
      mutate(
        ndvi_step = if_else(is.na(ndvi_step), ndvi, ndvi_step)
      )

    # handle step openness
    dest_openness <- .x %>%
      # select open classes - open agri, urban, water
      select(matches("lc_(2)|(0)|(5)")) %>%
      # sum the proportion
      rowSums(na.rm = TRUE)

    # assign dest openness if step openness is NA
    .x <- .x %>%
      mutate(
        step_openness = if_else(is.na(step_openness), dest_openness, step_openness)
      )
  })
)
```