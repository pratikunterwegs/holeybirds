
### Get destination covariates

```{r}
# radius in metres
use_radius <- 10

# prepare NDVI and LC velox
ndvi_velox <- velox(ndvi)
lc_velox <- velox(lc)
```

```{r}
tracks <- mutate(
  tracks,
  data = imap(data, function(.x, .y) {
    # print message
    message(sprintf("working on row %i", .y))

    # make buffers at destination
    step_end_buffer <- select(.x, x2_, y2_, case_, step_id_) %>%
      st_as_sf(coords = c("x2_", "y2_"), crs = 2039) %>%
      st_buffer(dist = use_radius)

    # get ndvi values
    mean_ndvi <- ndvi_velox$extract(
      sp = step_end_buffer, df = TRUE,
      fun = function(x) mean(x, na.rm = T)
    )
    mean_ndvi <- rename(mean_ndvi, ndvi = out)

    # landcover operation
    lc_vals <- lc_velox$extract(sp = step_end_buffer, df = TRUE)
    lc_prop <-
      lc_vals %>%
      # rename column
      rename(lc = "do.call..rbind...out.") %>%
      count(ID_sp, lc) %>%
      group_by(ID_sp) %>%
      # count the landcover classes and get proportion
      mutate(
        lc = sprintf("lc_%i", lc),
        prop = n / sum(n)
      ) %>%
      select(-n) %>%
      # pivot to wide format
      pivot_wider(
        names_from = lc,
        values_from = prop,
        values_fill = list(prop = 0)
      ) %>%
      ungroup()

    # create key
    step_end_buffer$ID_sp <- seq(nrow(step_end_buffer))

    # join
    step_end_buffer <- inner_join(
      step_end_buffer, mean_ndvi,
      by = "ID_sp"
    ) %>%
      inner_join(
        lc_prop,
        by = "ID_sp"
      )

    # join destination data with steps data
    .x <- mutate(.x,
      ID_sp = seq(nrow(.x))
    ) %>%
      inner_join(mean_ndvi, by = "ID_sp") %>%
      inner_join(lc_prop, by = "ID_sp") %>%
      select(-ID_sp)
  })
)
```

### Get step characteristics

```{r}
tracks <- mutate(
  tracks,
  data = imap(data, function(.x, .y) {

    # print message
    message(sprintf("working on row %i", .y))

    # get end points
    steps <- select(.x, x1_, y1_, x2_, y2_, step_id_, sl_)

    # make sf lines
    steps$geometry <- pmap(steps, function(x1_, y1_, x2_, y2_, step_id_, sl_) {
      # make linear path
      step_path <- st_linestring(
        matrix(c(x1_, y1_, x2_, y2_), nrow = 2, byrow = T)
      )
      step_path
    })

    # MAKE SFC
    steps$geometry <- st_sfc(steps$geometry, crs = 2039)

    # assign ID_sp
    steps$ID_sp <- seq(nrow(steps))

    # filter paths > 10 m, the long steps
    steps_long <- filter(steps, sl_ >= 10) %>%
      select(-sl_)

    # check steps long length
    if (nrow(steps_long) > 0) {

      # sample it every 10m
      steps_long <- steps_long %>%
        mutate(path_samples = st_line_sample(
          geometry,
          density = 1 / 10
        )) %>%
        filter(!st_is_empty(path_samples)) %>%
        select(-geometry)

      # make 5 m buffer
      steps_long <- steps_long %>%
        mutate(
          path_samples = st_buffer(path_samples, dist = 5),
          path_samples = st_sfc(path_samples)
        )

      # cast to multipolygon
      steps_long <- steps_long %>%
        mutate(path_samples = st_cast(path_samples, "MULTIPOLYGON"))

      # make sf and add temp id
      steps_long <- st_as_sf(steps_long, sf_column_name = "path_samples") %>%
        mutate(id_temp_ = seq(nrow(.)))

      # THIS CAN NOW BE PASSED TO VELOX -- some should give NAs due to EMPTY
      ndvi_path <- ndvi_velox$extract(
        sp = steps_long$path_samples,
        fun = function(x) mean(x, na.rm = T),
        df = TRUE
      ) %>%
        as_tibble() %>%
        rename(
          ndvi_step = out,
          id_temp_ = ID_sp
        )

      # get counts for
      lc_vals_path <- lc_velox$extract(sp = steps_long$path_samples, df = TRUE)
      lc_prop_path <-
        lc_vals_path %>%
        rename(lc = "do.call..rbind...out.") %>%
        count(ID_sp, lc) %>%
        group_by(ID_sp) %>%
        mutate(
          lc = sprintf("lc_%i", lc),
          prop = n / sum(n)
        ) %>%
        select(-n) %>%
        pivot_wider(
          names_from = lc,
          values_from = prop,
          values_fill = list(prop = 0)
        ) %>%
        ungroup()

      # add missing samples
      lc_prop_path <- full_join(
        lc_prop_path,
        tibble(ID_sp = seq(nrow(steps_long))),
        by = "ID_sp"
      )

      # get step openness
      data_openness <- lc_prop_path %>%
        # select open classes - open agri, urban, water
        select(matches("(2)|(0)|(5)")) %>%
        # sum the proportion
        rowSums(na.rm = TRUE) %>%
        tibble(
          id_temp_ = seq(length(.)),
          step_openness = .
        )

      # add assert
      assertthat::assert_that(
        nrow(data_openness) == nrow(steps_long),
        msg = "step openness values fewer than long steps"
      )

      # add to steps long
      steps_long <- steps_long %>%
        st_drop_geometry() %>%
        # add ndvi path
        left_join(ndvi_path, by = "id_temp_") %>%
        left_join(data_openness, by = "id_temp_")

      # remove excess data
      steps_long <- steps_long %>%
        select(-id_temp_)

      # bind with all steps
      steps <- steps %>%
        select(-geometry) %>%
        # join to long steps
        left_join(
          steps_long,
          by = c("x1_", "y1_", "x2_", "y2_", "step_id_", "ID_sp")
        )
    } else {
      steps <- mutate(
        steps,
        ndvi_step = NA_real_,
        step_openness = NA_real_
      )
    }

    # join to get full predictor data
    .x <- left_join(
      .x,
      steps,
      by = c("x1_", "x2_", "y1_", "y2_", "sl_", "step_id_")
    )

    # handle the short steps
    # first NDVI
    .x <- .x %>%
      mutate(
        ndvi_step = if_else(is.na(ndvi_step), ndvi, ndvi_step)
      )

    # handle step openness
    dest_openness <- .x %>%
      # select open classes - open agri, urban, water
      select(matches("lc_(2)|(0)|(5)")) %>%
      # sum the proportion
      rowSums(na.rm = TRUE)

    # assign dest openness if step openness is NA
    .x <- .x %>%
      mutate(
        step_openness = if_else(is.na(step_openness), dest_openness, step_openness)
      )
  })
)
```

### Prepare final predictors

```{r}
# add a very small movement distance (1e-5 metres --- less than a centimetre)
# to prevent infinite values
tracks <- mutate(
  tracks,
  data = map(data, function(df) {
    df <- mutate(df, log_sl = log(sl_ + 1e-5)) %>%
      filter(!is.na(log_sl), !is.infinite(log_sl))

    # add natural types
    data_lc_natural <- df %>%
      select(matches("lc_(3)|(4)|(5)")) %>%
      rowSums()

    df <- mutate(df, p_natural = data_lc_natural)

    # add urban and open if absent
    for (colname in c("lc_0", "lc_2")) {
      if (!colname %in% colnames(df)) {
        df[[colname]] <- 0
      }
    }

    # return df
    df
  })
)
```