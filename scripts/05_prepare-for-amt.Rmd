---
editor_options: 
  chunk_output_type: console
---

# Prepare data for SSF

Here we prepare the data for SSFs using the `amt` package.

## Load libraries and prepare files

```{r}
# libs for data
library(data.table)
library(lubridate)
library(glue)
library(dplyr)
library(tidyr)
library(sf)
library(purrr)

library(devtools)
if (!"velox" %in% installed.packages()) {
  install_github("hunzikp/velox")
} else {
  library(velox)
}

# library for SSF
library(amt)

# plot libraries
library(ggplot2)
library(colorspace)
```

```{r}
# read file names
files <- list.files("data/processed/data_preprocessed",
  full.names = TRUE
)
```

## Filter for stationary daytime positions

```{r}
# define daily data threshold
daily_data_threshold <- 100
day_start <- 5
day_end <- 20
stationary_time <- 2 # minutes

# read smoothed data and remove if not sufficient data
data <- lapply(files, function(file) {
  df <- fread(file)
  message(
    glue("data has {nrow(df)} rows")
  )
  df[, time := as.POSIXct(time, origin = "1970-01-01", tz = "Asia/Jerusalem")]

  # remove nighttime roosts --- this has ALREADY BEEN DONE
  # keeping this in for safety
  df <- df[hour >= day_start & hour < day_end, ]

  # remove data where bird is moving
  # df <- df[res_time > stationary_time]

  # split by date
  df_list <- split(df, by = "date")

  # remove data with fewer than N rows per day
  df_list <- df_list[vapply(df_list, function(le) {
    nrow(le) >= daily_data_threshold
  }, FUN.VALUE = TRUE)]

  # handle potentially empty data
  if (!is.null(df_list)) {
    df <- rbindlist(df_list)
    message(
      glue("total daytime data has {nrow(df)} rows")
    )
    return(df)
  } else {
    return(NULL)
  }
})

# bind list
data <- rbindlist(data)

# remove unnecessary columns
data[, `#` := NULL]
data <- data[, !c("speed_in", "speed_out")]
```

## Prepare for SSF

### Split by id and date

```{r}
# make tibble and nest by id and date + other identifiers
setDF(data)

# nest the tibble,
tracks <- nest(data,
  data = -matches(c("TAG", "date", "sp"))
)
```

### Make `amt` objects

```{r}
# make amt objects from the nested data
tracks <- mutate(tracks,
  data = map(data, function(df) {
    amt::make_track(
      tbl = df,
      .x = X,
      .y = Y,
      .t = time,
      crs = sp::CRS(
        st_crs(2039)$proj4string
      )
    )
  })
)
```

### Resample to 2 minutes

```{r}
# define resample seconds and tolerance
resample_interval_s <- 120
resample_tolerance <- 10

# min burst
min_n_burst <- 3 # min 5 positions in a row

# resample and filter for steps in burst
tracks <- mutate(
  tracks,
  data = lapply(data, function(df) {

    # resampling the track to 30 seconds with 5 second tolerance
    amt::track_resample(
      df,
      rate = seconds(resample_interval_s),
      tolerance = seconds(resample_tolerance)
    ) %>%

    ## filtering for bursts with at least 5 pos
    amt::filter_min_n_burst(
        min_n = min_n_burst
    )
  })
)
```

### Examine remaining data

```{r}
# count rows in data
tracks = mutate(
  tracks,
  nrow = map_int(data, nrow)
)
```

```{r}
# histogram of remaining data
ggplot(tracks)+
  geom_histogram(
    aes(
      nrow,
      fill = ..x.. > 20
    )
  )+
  facet_grid(sp ~ treat)
```


### Quality filters

Remove data with less than some threshold (currently 20) positions.

```{r}
min_daily_expected <- 20
min_steps_by_burst = 10

# filter out data with no rows remaining
tracks <- filter(
  tracks,
  purrr::map_lgl(data, function(df) {
    nrow(df) > min_daily_expected
  })
)

# now make steps by burst
tracks <- mutate(
  tracks,
  data = map(data, amt::steps_by_burst)
)

## remove with less than 5 steps
tracks <- filter(
  tracks,
  purrr::map_lgl(data, function(df) {

    # first filter for poor turning angles
    df <- filter(df, !is.na(ta_))

    nrow(df) >= min_steps_by_burst
  })
)
```

### Prepare alternate steps

```{r}
# define alternate steps
n_alt_steps <- 19

# prepare alternate steps and extract covariates
tracks <- mutate(
  tracks,
  data = imap(data, function(.x, .y) {

    # messages
    message(
      glue("operating row {.y}")
    )

    .x %>%
      # get 9 random potential steps
      amt::random_steps(n = n_alt_steps)
  })
)
```

Data still contains long term sparrow tracking and swallow data.

```{r}
save(tracks, file = "data/processed/data_for_ssf.Rds")
```
